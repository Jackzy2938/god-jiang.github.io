<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2020/01/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="滑动窗口操作"><a href="#滑动窗口操作" class="headerlink" title="滑动窗口操作"></a>滑动窗口操作</h2><ul>
<li>使用左右指针L、R</li>
<li>当一个数进入窗口时，必须从尾部进入，R向右移动一位</li>
<li>当一个数出窗口时，必须从头部出去，L向右移动一位</li>
<li>L、R只能向右移动，且R&gt;L</li>
</ul>
<hr>
<h2 id="算法原题-滑动窗口的最大值"><a href="#算法原题-滑动窗口的最大值" class="headerlink" title="算法原题(滑动窗口的最大值)"></a>算法原题(滑动窗口的最大值)</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。<br>例如，数组为[4, 3, 5, 4, 3, 3, 6, 7]，窗口大小为3时：<br>[4 3 5] 4 3 3 6 7 窗口中最大值为5<br>4[3 5 4] 3 3 6 7 窗口中最大值为5<br>4 3[5 4 3] 3 6 7 窗口中最大值为5<br>4 3 5[4 3 3] 6 7 窗口中最大值为4<br>4 3 5 4[3 3 6] 7 窗口中最大值为6<br>4 3 5 4 3[3 6 7] 窗口中最大值为7<br>如果数组长度为n，窗口大小为w，则一共产生n - w + 1个窗口的最大值。<br>请实现一个函数。<br>输入：整型数组arr，窗口大小为w。<br>输出：一个长度为n - w + 1的数组res，res[i]表示每一种窗口状态下的最大值。<br>以本题为例，结果应该返回{ 5,5,5,4,6,7 }。</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol>
<li>使用双向链表进行解答（LinkedList）</li>
<li>R的操作<ul>
<li>保证链表从左到右必须是从大到小，即头节点为最大值</li>
<li>每进入一个数，从链表的尾部进入，一但发现新的值比原来的链表的尾部大，先弹出，直到尾部的值大于即将插入的值，然后插入</li>
<li>每次压入的值都是原数组的下标值</li>
</ul>
</li>
<li>L的操作<ul>
<li>每一次进行L的操作时，判断链表的头节点是否过期，过期就直接弹出，否则继续向右移动</li>
<li>举例：当窗口的大小size=3，R=4，链表里面有4个数，大于size了，这个时候i=0就过期了，所以直接弹出头节点</li>
</ul>
</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMaxWindows</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//记录滑动窗口实时的最大值结果</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//双向链表，从左到右必须是从大到小的顺序</span></span><br><span class="line">            LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> length = num.length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; size || size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">//如果链表的尾部小于即将插入的值，则弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt;= num[i]) &#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//插入只能从尾部插入</span></span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                <span class="comment">//判断链表的头节点是否过期，从头部弹出</span></span><br><span class="line">                <span class="keyword">if</span> (i - queue.peekFirst() == size) &#123;</span><br><span class="line">                    queue.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当达到滑动窗口的size时，进行收集结果</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= size - <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add(num[queue.peekFirst()]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>以上就是滑动窗口最大值的解法，理解后可以去牛客网的剑指offer上练习</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.cnblogs.com/zzw1024/p/11042635.html" target="_blank" rel="noopener">一笔一画一人生</a></li>
<li><a href="https://blog.csdn.net/tangyuan_sibal/article/details/94486570" target="_blank" rel="noopener">经典算法总结</a></li>
</ul>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建gitalk</title>
    <url>/2019/12/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAgittalk/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>2019年1月份的时候就开始搭建了我的第一个博客hexo，部署到了Github Page上，也陆陆续续更新了一些大学时期学习的数据结构和算法内容，然后加了阅读量和访问量，后面发现没有评论系统的博客有点low的感觉，看了很多的评论系统，这里就不一一列举了，最后使用的是Gittalk评论系统。接下来就来介绍hexo集成Gittalk评论系统的全部过程。</p>
</blockquote>
<h2 id="关于Gitalk"><a href="#关于Gitalk" class="headerlink" title="关于Gitalk"></a>关于Gitalk</h2><blockquote>
<p>Gitalk是一个基于Github Issue和Preact开发的评论插件。使用Github账号登录，界面干净整洁，主要还是Gitalk支持MarkDown语法。（<strong>写过博客的都知道MarkDown好用</strong>）</p>
</blockquote>
<hr>
<h2 id="集成Gitalk"><a href="#集成Gitalk" class="headerlink" title="集成Gitalk"></a>集成Gitalk</h2><h3 id="建立评论仓库"><a href="#建立评论仓库" class="headerlink" title="建立评论仓库"></a>建立评论仓库</h3><ol>
<li>可以在你的个人Github上重新创建一个仓库来专门存放你的评论信息</li>
<li>可以直接使用你的hexo在Github上的仓库地址来存放你的评论信息，信息会放进你仓库里面的issue</li>
</ol>
<h3 id="新建一个OAuth-App"><a href="#新建一个OAuth-App" class="headerlink" title="新建一个OAuth App"></a>新建一个OAuth App</h3><p>​    地址：<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p>
<p><img src="/images/新建OAuth App.png" alt=""></p>
<p><img src="/images/OAuth说明.png" alt=""></p>
<p><strong>填完以上的信息会生成一个Client ID和一个Client Secret，等下的配置会用到这两个信息</strong></p>
<p><img src="/images/生成OAuth.png" alt=""></p>
<h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><ol>
<li>新建<code>/layout/_third-party/comments/gitalk.swig</code>文件，并添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改<code>/layout/_partials/comments.swig</code>，添加内容如下，与前面的<code>elseif</code>同一级别上：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line"> &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>layout/_third-party/comments/index.swig</code>，在最后一行添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>新建<code>/source/css/_common/components/third-party/gitalk.styl</code>文件，添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改<code>/source/css/_common/components/third-party/third-party.styl</code>，在最后一行上添加内容，引入样式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>在主题配置文件<code>next/_config.yml</code>中添加如下内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: github帐号  # 例：god-jiang   </span><br><span class="line">  repo: 仓库名称   # 例：god-jiang.github.io</span><br><span class="line">  ClientID: Client ID</span><br><span class="line">  ClientSecret: Client Secret</span><br><span class="line">  adminUser: github帐号 #指定可初始化评论账户</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure>
<p><strong>以上就是next主题中添加Gitalk评论的配置，博客上传到Github上后，打开某一篇文章就可以看到评论了。</strong></p>
<hr>
<h2 id="搭建完成效果"><a href="#搭建完成效果" class="headerlink" title="搭建完成效果"></a>搭建完成效果</h2><p><img src="/images/评论效果图.png" alt=""></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>到这里就已经是大功告成了，当你用github账号登录，第一次加载会比较慢，因为第一次加载会自动在你的仓库下创建相对应的issue。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://segmentfault.com/a/1190000014085547" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014085547</a></li>
<li><a href="https://blog.csdn.net/qq_35076330/article/details/99968291" target="_blank" rel="noopener">https://blog.csdn.net/qq_35076330/article/details/99968291</a></li>
<li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo优化</category>
      </categories>
  </entry>
  <entry>
    <title>荷兰国旗问题&amp;快排&amp;BFPRT算法</title>
    <url>/2019/12/26/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E5%BF%AB%E6%8E%92-BFPRT%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><blockquote>
<p>给定一个数组arr和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度为O(1)，时间复杂度为O(N)</p>
</blockquote>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>初始化less=-1，more=len(arr)，当前位置为cur=0。</p>
<ul>
<li>如果arr[cur]&lt;num，交换arr[cur]和arr[++less]的数，然后cur++</li>
<li>如果arr[cur]&gt;num，交换arr[cur]和arr[–more]的数，然后cur不变</li>
<li>如果当前位置上的数等于num，less和more均不变，cur++</li>
<li>当cur==more时，停止比较，返回</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetherLandsFlag</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;<span class="comment">//小于区域的边界</span></span><br><span class="line">        <span class="keyword">int</span> more = R + <span class="number">1</span>;<span class="comment">//大于区域的边界</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &lt; num) &#123;</span><br><span class="line">                swap(arr, ++less, cur++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; num) &#123;</span><br><span class="line">                swap(arr, --more, cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = partition(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h3><p><img src="/images/荷兰国旗.png" alt=""></p>
<hr>
<h2 id="稳定算法的定义"><a href="#稳定算法的定义" class="headerlink" title="稳定算法的定义"></a>稳定算法的定义</h2><blockquote>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这个排序算法是稳定的；否则称为不稳定的。</p>
</blockquote>
<hr>
<h2 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><blockquote>
<p>在一大堆数中求其前k大或前k小的问题，简称TOP-K问题。目前解决TOP-K问题最有效的算法是BFPRT算法，又称为中位数的中位数算法，该算法由Blum、Floyd、Pratt、Rivest、Tarjan提出，最坏时间复杂度为O(N)</p>
</blockquote>
<p>一般第一反应解决TOP-K问题就是对所有数据进行一次排序，然后取其前k即可，但是有两个问题：</p>
<ol>
<li>排序的平均复杂度为O(n*logn)，最坏时间复杂度为O(n^2)，不能保证较好的复杂度</li>
<li>我们只需要前k大的数，而对其余不需要的数也进行了排序，浪费了大量排序时间</li>
</ol>
<p>除了这种方法之外，堆排序也是一个比较好的选择， 可以维护一个大小为k的堆，时间复杂度为O(n*logk)。</p>
<h3 id="算法套路"><a href="#算法套路" class="headerlink" title="算法套路"></a>算法套路</h3><ol>
<li>对整个数组进行分组，每组5个数，不满5个的凑成最后一组</li>
<li>对每个组进行组内排序，组内5个数排序的时间复杂度为O(1)，所以总共有n/5个组，时间复杂度为O(N)</li>
<li>拿出排序后的每个组的中位数，组成一个新的n/5长度的数组</li>
<li>递归调用BFPRT算法，求出最后的中位数num</li>
<li>拿到BFPRT的返回的num，利用荷兰国旗算法把小于的放在数组的左边，等于的放在数组的中间，大于放在数组的右边。</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFPRT</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfprt</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、对arr数组进行分组，每5个为一组</span></span><br><span class="line">        <span class="comment">//2、进行组内排序，时间复杂度为O(N)，取出每个组的中位数</span></span><br><span class="line">        <span class="comment">//3、每个组的中位数组成一个n/5的数组new_arr</span></span><br><span class="line">        <span class="comment">//4、递归bfprt(new_arr,new_arr.length/2)</span></span><br><span class="line">        <span class="comment">//5、得到一个中位数num</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用这个中位数进行荷兰国旗算法，小于在左边，等于在中间，大于在右边</span></span><br><span class="line">    <span class="comment">//如果num==k,则该中位数就是第k大的数</span></span><br><span class="line">    <span class="comment">//如果num&lt;k，则递归求num之后的数组</span></span><br><span class="line">    <span class="comment">//如果num&gt;k，则递归求num之前的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度证明"><a href="#时间复杂度证明" class="headerlink" title="时间复杂度证明"></a>时间复杂度证明</h3><p><img src="/images/BFPRT时间复杂度.png" alt=""></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>算法导论</li>
<li>csdn博客</li>
</ol>
<blockquote>
<p>以上讲的是荷兰国旗的解法，可以运用于经典快排算法的partition操作，也可以用于BFPRT算法求解（TOP-K问题）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的位运算</title>
    <url>/2019/12/20/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算概述"><a href="#位运算概述" class="headerlink" title="位运算概述"></a>位运算概述</h2><p>从现代计算机中所有的数据都以二进制的形式存储在设备中。即0、1两种状态，计算机对二进制进行的运算（+、-、*、/）都叫位运算。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>计算a+b的值，在计算机中就是以二进制进行运算的。所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure>
<p><strong>所以，合理的运用位运算更能显著提高代码在机器上的运行效率。</strong></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">运算符</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左移</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:left">0011  =&gt;  0110</td>
</tr>
<tr>
<td style="text-align:center">右移</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:left">0110  =&gt;  0011</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">︳</td>
<td style="text-align:left">0011 <br> ——-  =&gt;1011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">0011 <br> ——-  =&gt;0011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位取反</td>
<td style="text-align:center">~</td>
<td style="text-align:left">0011  =&gt;1100</td>
</tr>
<tr>
<td style="text-align:center">按位异或 (相同为零不同为一)</td>
<td style="text-align:center">^</td>
<td style="text-align:left">0011 <br> ——-  =&gt;1000<br>1011</td>
</tr>
</tbody>
</table>
<h2 id="经典运用"><a href="#经典运用" class="headerlink" title="经典运用"></a>经典运用</h2><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step1:异或查看两个数进行加法操作后的结果</span></span><br><span class="line"><span class="comment">//step2:与运算计算出想对应的位置的进位结果，然后左移一位</span></span><br><span class="line"><span class="comment">//b代表的是两数相加是否有进位，有的话就继续，没有的话就结束得出相加后的答案</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;<span class="comment">//计算出相对应的位置相加后的结果</span></span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//计算出想对应的位置的进位，然后左移一位</span></span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个其实可以简写成return (a^b)+((a&amp;b)&lt;&lt;1);</span></span><br></pre></td></tr></table></figure>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>||a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            a = a &amp; (a-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不使用第三个变量的情况下交换两个变量的值"><a href="#不使用第三个变量的情况下交换两个变量的值" class="headerlink" title="不使用第三个变量的情况下交换两个变量的值"></a>不使用第三个变量的情况下交换两个变量的值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理：运用异或的特性</span></span><br><span class="line"><span class="comment">//A ^ B = C --&gt; C ^ A = B --&gt; C ^ B = A</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = x ^ y;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他运用"><a href="#其他运用" class="headerlink" title="其他运用"></a>其他运用</h2><ul>
<li>判断一个数的奇偶性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是偶数"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是奇数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两数的中位数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过位运算不会造成溢出</span></span><br><span class="line">	<span class="keyword">int</span> mid = a + (a - b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两树的平均数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; b)+((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天分享的常见位运算的经典问题，其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>运算</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之堆排序(Java实现)</title>
    <url>/2019/12/17/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="堆排序的介绍"><a href="#堆排序的介绍" class="headerlink" title="堆排序的介绍"></a>堆排序的介绍</h2><blockquote>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是<strong>完全二叉树</strong>。</p>
</blockquote>
<ul>
<li>完全二叉树：除了最后一层之外的其他每一层都被完全填充，每一层从左到右的填充数据，不能空缺</li>
<li>大根堆：任意一个节点的值均大于等于它的左右孩子的值，位于堆顶的节点值最大</li>
<li>小根堆：任意一个节点的值均小于等于它的左右孩子的值，位于堆顶的节点值最小</li>
</ul>
<p><strong>本节分享的堆排序以大根堆为例子</strong></p>
<h2 id="堆排序的实现步骤"><a href="#堆排序的实现步骤" class="headerlink" title="堆排序的实现步骤"></a>堆排序的实现步骤</h2><ul>
<li><h3 id="把一个数组调整为大根堆（heapInsert）"><a href="#把一个数组调整为大根堆（heapInsert）" class="headerlink" title="把一个数组调整为大根堆（heapInsert）"></a>把一个数组调整为大根堆（heapInsert）</h3><p>假设当前节点的下标为i，那么它的父亲节点为(i-1)/2，每次heapInsert的时候就把insert进来的节点与它的父亲节点进行比较，比它的父节点大就交换，一直重复调整</p>
</li>
<li><h3 id="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"><a href="#每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）" class="headerlink" title="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"></a>每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）</h3><p>每次把堆顶的节点放到最后，然后堆大小减1，然后调整为大根堆，一直重复，直到大根堆的大小为0为止</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapInsert操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapify操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[index] &gt; arr[largest] ? index : largest;</span><br><span class="line">            <span class="keyword">if</span> (largest == index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, index, largest);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>以上就是今天分享的堆排序，主要操作是heapInsert和heapify，时间复杂度为O(N*logN)，空间复杂度为O(1)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之归并排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="归并排序的介绍"><a href="#归并排序的介绍" class="headerlink" title="归并排序的介绍"></a>归并排序的介绍</h2><p>归并排序(英语：Merge sort，或Mergesort)，是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><strong>将两个有序的数列合并成一个大的有序的序列。通过递归，层层合并，即为归并。</strong></p>
<p><img src="/images/归并排序图示.png" alt=""></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治的结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证不溢出取start和end的中位数</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归排序并且合并</span></span><br><span class="line">        MergeSort(arr, start, mid);</span><br><span class="line">        MergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">        Merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p1] &gt; arr[p2]) &#123;</span><br><span class="line">                temp[p++] = arr[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[p++] = arr[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[p++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[p++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>1、以上就是今天分享的归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</p>
<p>2、归并排序的额外空间复杂度可以做到O(1)，但是非常难，不需要掌握，有一篇论文”归并排序内部缓存法”可以做到</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之快速排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>快速排序是一种原地排序，只需要一个很小的栈作为辅助空间，空间复杂度为O(logN)，所以适合在数据集比较大且无序的时候使用。</p>
<p><strong>时间复杂度</strong></p>
<p>时间复杂度比较复杂，最好的情况是O(N)，最差的时候是O(N^2)，所以平时说的O(N*logN)为其平均时间复杂度。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。</p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><p>partition方法中</p>
<p>1.选择数组中的第一个元素arr[startIndex]作为轴（pivot）</p>
<p>2.左指针为left，从最左边开始寻找第一个比pivot大的数</p>
<p>3.右指针为right，从最右面的一个元素开始向左寻找第一个小于等于pivot的数值</p>
<p>4.经过2，3两个步骤后，将会出现以下两种情况</p>
<p>​           （1）：left和right没有相遇，此时进行交换，swap（arr,left,right）;</p>
<p>​           （2）：left和right相遇，做swap（arr,startIndex,left），然后返回left</p>
<p>5.partition中返回pivot用于分割数组，下一次用于排序的数组被分割为(startIndex,pivot-1),(pivot+1,endIndex)两段，进行递归操作</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度O(n*logn)，空间复杂度O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &lt; endIndex) &#123;</span><br><span class="line">            <span class="comment">//找出基准</span></span><br><span class="line">            <span class="keyword">int</span> partition = partition(arr, startIndex, endIndex);</span><br><span class="line">            <span class="comment">//分成两边递归进行</span></span><br><span class="line">            quickSort(arr, startIndex, partition - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partition + <span class="number">1</span>, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找基准</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到left比基准大，right比基准小，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一轮完成，让left和right重合的位置和基准交换，返回基准的位置</span></span><br><span class="line">        swap(arr, startIndex, left);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两数交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/快排运行截图.png" alt=""></p>
<blockquote>
<p>1、以上就是今天分享的快速排序，时间复杂度为O(N<em>logN)，空间复杂度为O(N\</em>logN)</p>
<p>2、快排是不稳定排序，要想做到稳定性是可以的，但是非常难，不需要掌握，有一篇论文叫”01 stable sort”可以做到</p>
<p>3、有一道题目，是奇数放数组左边，偶数放在数组右边，还要求原始的相对次序不变，额外空间复杂度为O(1)，碰到这个问题，直接可以怼面试官，根本不可能做出来</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>神级遍历-morris</title>
    <url>/2019/12/15/%E7%A5%9E%E7%BA%A7%E9%81%8D%E5%8E%86-morris/</url>
    <content><![CDATA[<h2 id="morris遍历介绍"><a href="#morris遍历介绍" class="headerlink" title="morris遍历介绍"></a>morris遍历介绍</h2><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p>
<p>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</p>
<h2 id="morris遍历的实现原则"><a href="#morris遍历的实现原则" class="headerlink" title="morris遍历的实现原则"></a>morris遍历的实现原则</h2><p><strong>记作当前节点为cur。</strong></p>
<ol>
<li>如果cur无左孩子，cur向右移动（cur=cur.right）</li>
<li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<ol>
<li>如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li>
<li>如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li>
</ol>
</li>
</ol>
<p>实现以上的原则，即实现了morris遍历。</p>
<h2 id="morris遍历的实质"><a href="#morris遍历的实质" class="headerlink" title="morris遍历的实质"></a>morris遍历的实质</h2><p>建立一种机制，对<strong>于没有左子树的节点只到达一次，对于有左子树的节点会到达两次</strong></p>
<h2 id="morris遍历的实例"><a href="#morris遍历的实例" class="headerlink" title="morris遍历的实例"></a>morris遍历的实例</h2><p>一个树若按层遍历的结构为{1,2,3,4,5,6,7}，即该树为满二叉树，头结点值为1，左右孩子为2,3，叶节点为4,5,6,7</p>
<p>我们按照morris遍历来遍历该树。</p>
<p>1）首先cur来到头结点1，按照morris原则的第二条第一点，它存在左孩子，cur左子树上最右的节点为5，它的right指针指向空，所以让其指向1，cur向左移动到2。</p>
<p>2）2有左孩子，且它左子树最右的节点4指向空，按照morris原则的第二条第一点,让4的right指针指向2，cur向左移动到4</p>
<p>3）4不存在左孩子，按照morris原则的第一条，cur向右移动，在第二步中，4的right指针已经指向了2，所以cur会回到2</p>
<p>4）重新回到2，有左孩子，它左子树最右的节点为4，但是在第二步中，4的right指针已经指向了2，不为空。所以按照morris原则的第二条第二点，2向右移动到5，同时4的right指针重新指向空</p>
<p>5）5不存在左孩子，按照morris原则的第一条，cur向右移动，在第一步中，5的right指针已经指向了1，所以cur会回到1</p>
<p>6）cur回到1，回到头结点，左子树遍历完成，1有左孩子，左子树上最右的节点为5，它的right指针指向1，按照morris原则的第二条第二点，1向右移动到3，同时5的right指针重新指回空</p>
<p>……</p>
<p>当到达最后一个节点7时，按照流程下来，此时7无左右孩子，遍历结束。</p>
<h2 id="morris代码实现（前序、中序、后序遍历）"><a href="#morris代码实现（前序、中序、后序遍历）" class="headerlink" title="morris代码实现（前序、中序、后序遍历）"></a>morris代码实现（前序、中序、后序遍历）</h2><p>前序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续遍历（复杂一点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           mostRight = cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                   mostRight = mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   mostRight.right = cur;</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                   printEdge(cur.left);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       printEdge(head);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node tail =reverseEdge(node);</span><br><span class="line">       Node cur = tail;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span> )&#123;</span><br><span class="line">           System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">           cur =cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       reverseEdge(tail);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = node.right;</span><br><span class="line">           node.right = pre;</span><br><span class="line">           pre = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天所要分享的morris遍历，神级算法，时间复杂度为O(N)，空间复杂度为O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>链表反转解法</title>
    <url>/2019/04/20/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>当初大二学习数据结构的时候，有许多数据结构我都学得有点懵，总感觉没有一个系统的概括和总结，导致我的链表学得一般。后来班上有个同学微信跟我说叫我关注”程序员小灰”这个公众号，说他讲得很生动形象，最后关注了一波，看了他里面一道经典的面试题——链表反转。接下来就来讲解链表反转的解法。</p>
</blockquote>
<h2 id="链表反转图示"><a href="#链表反转图示" class="headerlink" title="链表反转图示"></a>链表反转图示</h2><p><img src="/images/链表反转解法/1.png" alt=""></p>
<h2 id="解法说明"><a href="#解法说明" class="headerlink" title="解法说明"></a>解法说明</h2><ol>
<li><p>链表反转的本质其实就是把每一个节点原本指向下一个节点的next的指针，反转过来指向它的前置节点。</p>
<p><img src="/images/链表反转解法/2.png" alt=""></p>
</li>
<li><p>进行链表反转的时候，需要同时知道三个节点才能进行反转。</p>
<p><img src="/images/链表反转解法/3.png" alt=""></p>
</li>
</ol>
<h2 id="解法步骤"><a href="#解法步骤" class="headerlink" title="解法步骤"></a>解法步骤</h2><ol>
<li><p>以p2节点为根，把p2节点原本指向p3的next指针反转，指向p1</p>
<p><img src="/images/链表反转解法/4.png" alt=""></p>
</li>
<li><p>三个临时节点引用p1，p2，p3分别向后移动一位</p>
<p><img src="/images/链表反转解法/5.png" alt=""></p>
</li>
<li><p>重复”1”的工作，以p2节点为根，把p2节点原本指向p3的next指针反转，指向p1</p>
<p><img src="/images/链表反转解法/6.png" alt=""></p>
</li>
<li><p>重复”2”的工作，三个临时节点引用p1，p2，p3分别向后移动一位</p>
<p><img src="/images/链表反转解法/7.png" alt=""></p>
</li>
<li><p>继续重复以上的工作，一直到p2为空为止</p>
<p><img src="/images/链表反转解法/8.png" alt=""></p>
</li>
<li><p>最后，把head节点的next指向空，成为反转链表的尾节点。并把p1赋值给head，让p1所在节点成为反转链表的头节点</p>
<p><img src="/images/链表反转解法/9.png" alt=""></p>
</li>
</ol>
<p>​    <strong>听完上面的讲解，估计有点懵逼，来看看代码的实现，再结合上面的图示步骤，相信你就会理解链表反转了</strong></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        ListNode p3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p3 = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head = p1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>对于链表的反转就介绍到这里，感谢大家的支持。嘻嘻嘻~~~</p>
</blockquote>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul>
<li>程序员小灰公众号</li>
<li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网原题链接</a></li>
</ul>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列算法</title>
    <url>/2019/03/02/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="全排列算法详细解析"><a href="#全排列算法详细解析" class="headerlink" title="全排列算法详细解析"></a>全排列算法详细解析</h2><p>全排列在笔试面试和ACM竞赛中很热门，因为它难度适中，既可以考察递归实现，又能进一步考察非递归的实现，便于区分出考生的水平。（<strong>自己的心得：回溯是思想，深搜是本质，递归是实现</strong>）</p>
<h4 id="一、全排列的递归实现（以下所有代码以java为主）"><a href="#一、全排列的递归实现（以下所有代码以java为主）" class="headerlink" title="一、全排列的递归实现（以下所有代码以java为主）"></a>一、全排列的递归实现（以下所有代码以java为主）</h4><p>以abcd为例，共有24种排列方式，abcd,abdc,acbd,acdb…….，因此可以知道——<em>全排列就是从第一个数字起每个数分别与它后面的数字交换。</em>递归的代码如下：</p>
<pre><code>public class Main{
    public static int count=0;
    public static void swap(char[] a,int i,int j){
        char tmp = a[i];
        a[i]=a[j];
        a[j]=tmp;
}

    public static void perm(char[] a,int st,int len){
        if(st==len-1){
            for(int i=0;i&lt;len;i++){
                System.out.print(a[i]);
            }
            System.out.println(&quot;&quot;);
            count++;
        }else{
            for(int i=st;i&lt;len;i++){
                swap(a,st,i);
                perm(a,st+1,len);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {
        char[] a=&quot;abcd&quot;.toCharArray();
        perm(a,0,4);
        System.out.println(&quot;总共有：&quot;+count+&quot;种&quot;);
    }
}
</code></pre><h6 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm.jpg" alt="全排列的结果"></p>
<h3 id="二、以蓝桥杯里面的一道例题来使用全排列解决"><a href="#二、以蓝桥杯里面的一道例题来使用全排列解决" class="headerlink" title="二、以蓝桥杯里面的一道例题来使用全排列解决"></a>二、以蓝桥杯里面的一道例题来使用全排列解决</h3><p><strong>题目：</strong><br><em>凑算式:  A+B/C+DEF/GHI = 10<br>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如： 6+8/3+952/714就是一种解法, 5+3/1+972/486是另一种解法。这个算式一共有多少种解法？</em></p>
<p>代码如下：</p>
<pre><code>public class Main {
    static int count=0;
    public static void swap(char[] a,int i,int j){
        char temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
    public static boolean check(char[] a){
        double[] num = new double[9];
        for(int i=0;i&lt;9;i++){
            num[i]=a[i]-&apos;0&apos;;
        }
        if(num[0]+num[1]*1.0/num[2]+(num[3]*100+num[4]*10+num[5])*1.0/(num[6]*100+num[7]*10+num[8])==10){
            return true;
        }
        return false;
    }

    public static void perm(char[] a,int st,int length){
        if(st==length-1){
            if(check(a)){
                count++;
            }
        }else{
            for(int i=st;i&lt;length;i++){
                swap(a,st,i);
                perm(a,st+1,length);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {    
        char[] a=&quot;123456789&quot;.toCharArray();
        perm(a,0,9);
        System.out.println(&quot;共有&quot;+count+&quot;种解法&quot;);
    }
}
</code></pre><h6 id="运行结果如下：-1"><a href="#运行结果如下：-1" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm01.jpg" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>全排列就是从第一个数字起每个数分别与它后面的数字交换</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis开发流程</title>
    <url>/2019/02/16/MyBatis%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>通过这几天的学习，大概懂得了mybatis的开发流程还有基础的CURD操作，就想着把它写下来，接下来会写下mybatis框架的开发步骤，举例代码就用insert，其他read、update、delete大致跟insert一样。<br><a id="more"></a></p>
<h2 id="mybatis开发步骤"><a href="#mybatis开发步骤" class="headerlink" title="mybatis开发步骤"></a>mybatis开发步骤</h2><h4 id="一、导入相对应的jar包"><a href="#一、导入相对应的jar包" class="headerlink" title="一、导入相对应的jar包"></a>一、导入相对应的jar包</h4><p>如图所示：<br><img src="/images/myBatisJar.jpg" alt="jar"></p>
<h4 id="二、写主配置文件myBatis-config-xml"><a href="#二、写主配置文件myBatis-config-xml" class="headerlink" title="二、写主配置文件myBatis-config.xml"></a>二、写主配置文件myBatis-config.xml</h4><p><code>&lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
    &lt;mapper resource=&quot;god/jiang/entity/DeptMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></p>
<h4 id="三、写映射文件"><a href="#三、写映射文件" class="headerlink" title="三、写映射文件"></a>三、写映射文件</h4><p>例如创建一个xxx.java的javebean,同时就要创建一个xxx.Mapper.xml来映射数据库的字段，还有要先写CURD的SQL语句，如图所示：<br><img src="/images/myBatisMapper.jpg" alt="mapper"></p>
<h4 id="四、写Dao的接口和实现（以insert为例子）"><a href="#四、写Dao的接口和实现（以insert为例子）" class="headerlink" title="四、写Dao的接口和实现（以insert为例子）"></a>四、写Dao的接口和实现（以insert为例子）</h4><p>1.先用Resources.getResourcesAsReader(myBatis-config.xml)读取主配置文件<br>2.构建sessionFactory<br>3.创建session(mybatis默认开启事务)<br>4.业务逻辑（insert为例子）<br>5.提交事务<br>代码如下：<br><img src="/images/myBatisSave.jpg" alt="insert"></p>
<h4 id="五、test（省略）"><a href="#五、test（省略）" class="headerlink" title="五、test（省略）"></a>五、test（省略）</h4><p>…<br>…<br>…</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote>
<p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。<br>以上就是我对MyBatis的开发流程的理解和CURD示例。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>学习mybatis的记录初体验</title>
    <url>/2019/01/22/%E5%AD%A6%E4%B9%A0mybatis%E7%9A%84%E8%AE%B0%E5%BD%9501/</url>
    <content><![CDATA[<p>今天刚开始学习mybatis，听了mybatis和hibernate之间的比较，大致是这样的：<br>一、灵活性：mybatis可以直接使用SQL语句，灵活性较高<br>二、效率性：mybatis直接用SQL，效率高（hibernate使用hql语句，底层需要转换成<br>SQL来操作数据库，时间上有消耗）<br>三、移植性：hibernate更好，因为hibernate用配置文件关联数据库，用hql语句与<br>数据库无直接关系</p>
<p>听完课学了大概一个小时，弄懂了mybatis开发的大致流程，但是轮到我自己动手操<br>作的时候，一直保空指针异常，初学者总是遇到这个问题，弄了我将近2个多小时，<br>最后才知道原来要使用SQL语句的时候，SqlSession.insert(1,2)传的参数弄错了，<br>第一个参数要传的是mapper.xml的命名空间加定义的id来定位，第二个参数就是你<br>要传的值。</p>
<p>总的来说，我还是觉得学习编程，理论固然重要，但是动手能力也很重要，编码能力<br>也很重要，这就是我学习mybatis的初次体验。</p>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>god_jiang的第一篇博客</title>
    <url>/2019/01/17/god-jiang-title/</url>
    <content><![CDATA[<p>这是我得第一个博客网站，也不知道说些啥，就是假期大家好好学习，不要过度玩电脑游戏，偶尔放松一下没啥，但是关键得ssm框架还是得先学好，下学期好找实习。。。。</p>
]]></content>
  </entry>
</search>
