<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>有趣的位运算</title>
    <url>/2019/12/20/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算概述"><a href="#位运算概述" class="headerlink" title="位运算概述"></a>位运算概述</h2><p>从现代计算机中所有的数据都以二进制的形式存储在设备中。即0、1两种状态，计算机对二进制进行的运算（+、-、*、/）都叫位运算。示例：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>计算a+b的值，在计算机中就是以二进制进行运算的。所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure>
<p><strong>所以，合理的运用位运算更能显著提高代码在机器上的运行效率。</strong></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">运算符</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左移</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:left">0011  =&gt;  0110</td>
</tr>
<tr>
<td style="text-align:center">右移</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:left">0110  =&gt;  0011</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">︳</td>
<td style="text-align:left">0011 <br> ——-  =&gt; 1011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">0011 <br> ——-  =&gt; 0011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位取反</td>
<td style="text-align:center">~</td>
<td style="text-align:left">0011  =&gt; 1100</td>
</tr>
<tr>
<td style="text-align:center">按位异或 (相同为零不同为一)</td>
<td style="text-align:center">^</td>
<td style="text-align:left">0011 <br> ——-  =&gt; 1000<br>1011</td>
</tr>
</tbody>
</table>
<h2 id="经典运用"><a href="#经典运用" class="headerlink" title="经典运用"></a>经典运用</h2><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step1:异或查看两个数进行加法操作后的结果</span></span><br><span class="line"><span class="comment">//step2:与运算计算出想对应的位置的进位结果，然后左移一位</span></span><br><span class="line"><span class="comment">//b代表的是两数相加是否有进位，有的话就继续，没有的话就结束得出相加后的答案</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;<span class="comment">//计算出相对应的位置相加后的结果</span></span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//计算出想对应的位置的进位，然后左移一位</span></span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个其实可以简写成return (a^b)+((a&amp;b)&lt;&lt;1);</span></span><br></pre></td></tr></table></figure>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>||a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            a = a &amp; (a-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不使用第三个变量的情况下交换两个变量的值"><a href="#不使用第三个变量的情况下交换两个变量的值" class="headerlink" title="不使用第三个变量的情况下交换两个变量的值"></a>不使用第三个变量的情况下交换两个变量的值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理：运用异或的特性</span></span><br><span class="line"><span class="comment">//A ^ B = C --&gt; C ^ A = B --&gt; C ^ B = A</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	x ^= y;</span><br><span class="line">   	y ^= x;</span><br><span class="line">    x ^= y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他运用"><a href="#其他运用" class="headerlink" title="其他运用"></a>其他运用</h2><ul>
<li>判断一个数的奇偶性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是偶数"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是奇数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两数的中位数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过位运算不会造成溢出</span></span><br><span class="line">	<span class="keyword">int</span> mid = a + (a - b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两树的平均数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; b)+((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天分享的常见位运算的经典问题，其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>运算</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之堆排序(Java实现)</title>
    <url>/2019/12/17/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="堆排序的介绍"><a href="#堆排序的介绍" class="headerlink" title="堆排序的介绍"></a>堆排序的介绍</h2><blockquote>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是<strong>完全二叉树</strong>。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>完全二叉树：除了最后一层之外的其他每一层都被完全填充，每一层从左到右的填充数据，不能空缺</li>
<li>大根堆：任意一个节点的值均大于等于它的左右孩子的值，位于堆顶的节点值最大</li>
<li>小根堆：任意一个节点的值均小于等于它的左右孩子的值，位于堆顶的节点值最小</li>
</ul>
<p><strong>本节分享的堆排序以大根堆为例子</strong></p>
<h2 id="堆排序的实现步骤"><a href="#堆排序的实现步骤" class="headerlink" title="堆排序的实现步骤"></a>堆排序的实现步骤</h2><ul>
<li><h3 id="把一个数组调整为大根堆（heapInsert）"><a href="#把一个数组调整为大根堆（heapInsert）" class="headerlink" title="把一个数组调整为大根堆（heapInsert）"></a>把一个数组调整为大根堆（heapInsert）</h3><p>假设当前节点的下标为i，那么它的父亲节点为(i-1)/2，每次heapInsert的时候就把insert进来的节点与它的父亲节点进行比较，比它的父节点大就交换，一直重复调整</p>
</li>
<li><h3 id="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"><a href="#每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）" class="headerlink" title="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"></a>每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）</h3><p>每次把堆顶的节点放到最后，然后堆大小减1，然后调整为大根堆，一直重复，直到大根堆的大小为0为止</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapInsert操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapify操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[index] &gt; arr[largest] ? index : largest;</span><br><span class="line">            <span class="keyword">if</span> (largest == index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, index, largest);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>以上就是今天分享的堆排序，主要操作是heapInsert和heapify，时间复杂度为O(N*logN)，空间复杂度为O(1)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之归并排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="归并排序的介绍"><a href="#归并排序的介绍" class="headerlink" title="归并排序的介绍"></a>归并排序的介绍</h2><p>归并排序(英语：Merge sort，或Mergesort)，是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><strong>将两个有序的数列合并成一个大的有序的序列。通过递归，层层合并，即为归并。</strong></p>
<p><img src="/images/归并排序图示.png" alt=""></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治的结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证不溢出取start和end的中位数</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归排序并且合并</span></span><br><span class="line">        MergeSort(arr, start, mid);</span><br><span class="line">        MergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">        Merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p1] &gt; arr[p2]) &#123;</span><br><span class="line">                temp[p++] = arr[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[p++] = arr[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[p++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[p++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>以上就是今天分享的归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之快速排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>快速排序是一种原地排序，只需要一个很小的栈作为辅助空间，空间复杂度为O(logN)，所以适合在数据集比较大且无序的时候使用。</p>
<p><strong>时间复杂度</strong></p>
<p>时间复杂度比较复杂，最好的情况是O(N)，最差的时候是O(N^2)，所以平时说的O(N*logN)为其平均时间复杂度。</p>
<a id="more"></a>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。</p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><p>partition方法中</p>
<p>1.选择数组中的第一个元素arr[startIndex]作为轴（pivot）</p>
<p>2.左指针为left，从最左边开始寻找第一个比pivot大的数</p>
<p>3.右指针为right，从最右面的一个元素开始向左寻找第一个小于等于pivot的数值</p>
<p>4.经过2，3两个步骤后，将会出现以下两种情况</p>
<p>​           （1）：left和right没有相遇，此时进行交换，swap（arr,left,right）;</p>
<p>​           （2）：left和right相遇，做swap（arr,startIndex,left），然后返回left</p>
<p>5.partition中返回pivot用于分割数组，下一次用于排序的数组被分割为(startIndex,pivot-1),(pivot+1,endIndex)两段，进行递归操作</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度O(n*logn)，空间复杂度O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &lt; endIndex) &#123;</span><br><span class="line">            <span class="comment">//找出基准</span></span><br><span class="line">            <span class="keyword">int</span> partition = partition(arr, startIndex, endIndex);</span><br><span class="line">            <span class="comment">//分成两边递归进行</span></span><br><span class="line">            quickSort(arr, startIndex, partition - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partition + <span class="number">1</span>, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找基准</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到left比基准大，right比基准小，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一轮完成，让left和right重合的位置和基准交换，返回基准的位置</span></span><br><span class="line">        swap(arr, startIndex, left);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两数交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/快排运行截图.png" alt=""></p>
<blockquote>
<p>以上就是今天分享的快速排序，时间复杂度为O(N<em>logN)，空间复杂度为O(N\</em>logN)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>神级遍历-morris</title>
    <url>/2019/12/15/%E7%A5%9E%E7%BA%A7%E9%81%8D%E5%8E%86-morris/</url>
    <content><![CDATA[<h2 id="morris遍历介绍"><a href="#morris遍历介绍" class="headerlink" title="morris遍历介绍"></a>morris遍历介绍</h2><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p>
<p>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</p>
<a id="more"></a>
<h2 id="morris遍历的实现原则"><a href="#morris遍历的实现原则" class="headerlink" title="morris遍历的实现原则"></a>morris遍历的实现原则</h2><p><strong>记作当前节点为cur。</strong></p>
<ol>
<li>如果cur无左孩子，cur向右移动（cur=cur.right）</li>
<li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<ol>
<li>如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li>
<li>如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li>
</ol>
</li>
</ol>
<p>实现以上的原则，即实现了morris遍历。</p>
<h2 id="morris遍历的实质"><a href="#morris遍历的实质" class="headerlink" title="morris遍历的实质"></a>morris遍历的实质</h2><p>建立一种机制，对<strong>于没有左子树的节点只到达一次，对于有左子树的节点会到达两次</strong></p>
<h2 id="morris遍历的实例"><a href="#morris遍历的实例" class="headerlink" title="morris遍历的实例"></a>morris遍历的实例</h2><p>一个树若按层遍历的结构为{1,2,3,4,5,6,7}，即该树为满二叉树，头结点值为1，左右孩子为2,3，叶节点为4,5,6,7</p>
<p>我们按照morris遍历来遍历该树。</p>
<p>1）首先cur来到头结点1，按照morris原则的第二条第一点，它存在左孩子，cur左子树上最右的节点为5，它的right指针指向空，所以让其指向1，cur向左移动到2。</p>
<p>2）2有左孩子，且它左子树最右的节点4指向空，按照morris原则的第二条第一点,让4的right指针指向2，cur向左移动到4</p>
<p>3）4不存在左孩子，按照morris原则的第一条，cur向右移动，在第二步中，4的right指针已经指向了2，所以cur会回到2</p>
<p>4）重新回到2，有左孩子，它左子树最右的节点为4，但是在第二步中，4的right指针已经指向了2，不为空。所以按照morris原则的第二条第二点，2向右移动到5，同时4的right指针重新指向空</p>
<p>5）5不存在左孩子，按照morris原则的第一条，cur向右移动，在第一步中，5的right指针已经指向了1，所以cur会回到1</p>
<p>6）cur回到1，回到头结点，左子树遍历完成，1有左孩子，左子树上最右的节点为5，它的right指针指向1，按照morris原则的第二条第二点，1向右移动到3，同时5的right指针重新指回空</p>
<p>……</p>
<p>当到达最后一个节点7时，按照流程下来，此时7无左右孩子，遍历结束。</p>
<h2 id="morris代码实现（前序、中序、后序遍历）"><a href="#morris代码实现（前序、中序、后序遍历）" class="headerlink" title="morris代码实现（前序、中序、后序遍历）"></a>morris代码实现（前序、中序、后序遍历）</h2><p>前序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续遍历（复杂一点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           mostRight = cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                   mostRight = mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   mostRight.right = cur;</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                   printEdge(cur.left);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       printEdge(head);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node tail =reverseEdge(node);</span><br><span class="line">       Node cur = tail;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span> )&#123;</span><br><span class="line">           System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">           cur =cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       reverseEdge(tail);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = node.right;</span><br><span class="line">           node.right = pre;</span><br><span class="line">           pre = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天所要分享的morris遍历，神级算法，时间复杂度为O(N)，空间复杂度为O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列算法</title>
    <url>/2019/03/02/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="全排列算法详细解析"><a href="#全排列算法详细解析" class="headerlink" title="全排列算法详细解析"></a>全排列算法详细解析</h2><p>全排列在笔试面试和ACM竞赛中很热门，因为它难度适中，既可以考察递归实现，又能进一步考察非递归的实现，便于区分出考生的水平。（<strong>自己的心得：回溯是思想，深搜是本质，递归是实现</strong>）</p>
<a id="more"></a>
<h4 id="一、全排列的递归实现（以下所有代码以java为主）"><a href="#一、全排列的递归实现（以下所有代码以java为主）" class="headerlink" title="一、全排列的递归实现（以下所有代码以java为主）"></a>一、全排列的递归实现（以下所有代码以java为主）</h4><p>以abcd为例，共有24种排列方式，abcd,abdc,acbd,acdb…….，因此可以知道——<em>全排列就是从第一个数字起每个数分别与它后面的数字交换。</em>递归的代码如下：</p>
<pre><code>public class Main{
    public static int count=0;
    public static void swap(char[] a,int i,int j){
        char tmp = a[i];
        a[i]=a[j];
        a[j]=tmp;
}

    public static void perm(char[] a,int st,int len){
        if(st==len-1){
            for(int i=0;i&lt;len;i++){
                System.out.print(a[i]);
            }
            System.out.println(&quot;&quot;);
            count++;
        }else{
            for(int i=st;i&lt;len;i++){
                swap(a,st,i);
                perm(a,st+1,len);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {
        char[] a=&quot;abcd&quot;.toCharArray();
        perm(a,0,4);
        System.out.println(&quot;总共有：&quot;+count+&quot;种&quot;);
    }
}
</code></pre><h6 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm.jpg" alt="全排列的结果"></p>
<h3 id="二、以蓝桥杯里面的一道例题来使用全排列解决"><a href="#二、以蓝桥杯里面的一道例题来使用全排列解决" class="headerlink" title="二、以蓝桥杯里面的一道例题来使用全排列解决"></a>二、以蓝桥杯里面的一道例题来使用全排列解决</h3><p><strong>题目：</strong><br><em>凑算式:  A+B/C+DEF/GHI = 10<br>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如： 6+8/3+952/714就是一种解法, 5+3/1+972/486是另一种解法。这个算式一共有多少种解法？</em></p>
<p>代码如下：</p>
<pre><code>public class Main {
    static int count=0;
    public static void swap(char[] a,int i,int j){
        char temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
    public static boolean check(char[] a){
        double[] num = new double[9];
        for(int i=0;i&lt;9;i++){
            num[i]=a[i]-&apos;0&apos;;
        }
        if(num[0]+num[1]*1.0/num[2]+(num[3]*100+num[4]*10+num[5])*1.0/(num[6]*100+num[7]*10+num[8])==10){
            return true;
        }
        return false;
    }

    public static void perm(char[] a,int st,int length){
        if(st==length-1){
            if(check(a)){
                count++;
            }
        }else{
            for(int i=st;i&lt;length;i++){
                swap(a,st,i);
                perm(a,st+1,length);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {    
        char[] a=&quot;123456789&quot;.toCharArray();
        perm(a,0,9);
        System.out.println(&quot;共有&quot;+count+&quot;种解法&quot;);
    }
}
</code></pre><h6 id="运行结果如下：-1"><a href="#运行结果如下：-1" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm01.jpg" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>全排列就是从第一个数字起每个数分别与它后面的数字交换</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis开发流程</title>
    <url>/2019/02/16/MyBatis%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>通过这几天的学习，大概懂得了mybatis的开发流程还有基础的CURD操作，就想着把它写下来，接下来会写下mybatis框架的开发步骤，举例代码就用insert，其他read、update、delete大致跟insert一样。<br><a id="more"></a></p>
<h2 id="mybatis开发步骤"><a href="#mybatis开发步骤" class="headerlink" title="mybatis开发步骤"></a>mybatis开发步骤</h2><h4 id="一、导入相对应的jar包"><a href="#一、导入相对应的jar包" class="headerlink" title="一、导入相对应的jar包"></a>一、导入相对应的jar包</h4><p>如图所示：<br><img src="/images/myBatisJar.jpg" alt="jar"></p>
<h4 id="二、写主配置文件myBatis-config-xml"><a href="#二、写主配置文件myBatis-config-xml" class="headerlink" title="二、写主配置文件myBatis-config.xml"></a>二、写主配置文件myBatis-config.xml</h4><p><code>&lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
    &lt;mapper resource=&quot;god/jiang/entity/DeptMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></p>
<h4 id="三、写映射文件"><a href="#三、写映射文件" class="headerlink" title="三、写映射文件"></a>三、写映射文件</h4><p>例如创建一个xxx.java的javebean,同时就要创建一个xxx.Mapper.xml来映射数据库的字段，还有要先写CURD的SQL语句，如图所示：<br><img src="/images/myBatisMapper.jpg" alt="mapper"></p>
<h4 id="四、写Dao的接口和实现（以insert为例子）"><a href="#四、写Dao的接口和实现（以insert为例子）" class="headerlink" title="四、写Dao的接口和实现（以insert为例子）"></a>四、写Dao的接口和实现（以insert为例子）</h4><p>1.先用Resources.getResourcesAsReader(myBatis-config.xml)读取主配置文件<br>2.构建sessionFactory<br>3.创建session(mybatis默认开启事务)<br>4.业务逻辑（insert为例子）<br>5.提交事务<br>代码如下：<br><img src="/images/myBatisSave.jpg" alt="insert"></p>
<h4 id="五、test（省略）"><a href="#五、test（省略）" class="headerlink" title="五、test（省略）"></a>五、test（省略）</h4><p>…<br>…<br>…</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote>
<p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。<br>以上就是我对MyBatis的开发流程的理解和CURD示例。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>学习mybatis的记录初体验</title>
    <url>/2019/01/22/%E5%AD%A6%E4%B9%A0mybatis%E7%9A%84%E8%AE%B0%E5%BD%9501/</url>
    <content><![CDATA[<p>今天刚开始学习mybatis，听了mybatis和hibernate之间的比较，大致是这样的：<br>一、灵活性：mybatis可以直接使用SQL语句，灵活性较高<br>二、效率性：mybatis直接用SQL，效率高（hibernate使用hql语句，底层需要转换成<br>SQL来操作数据库，时间上有消耗）<br>三、移植性：hibernate更好，因为hibernate用配置文件关联数据库，用hql语句与<br>数据库无直接关系<br><a id="more"></a><br>听完课学了大概一个小时，弄懂了mybatis开发的大致流程，但是轮到我自己动手操<br>作的时候，一直保空指针异常，初学者总是遇到这个问题，弄了我将近2个多小时，<br>最后才知道原来要使用SQL语句的时候，SqlSession.insert(1,2)传的参数弄错了，<br>第一个参数要传的是mapper.xml的命名空间加定义的id来定位，第二个参数就是你<br>要传的值。</p>
<p>总的来说，我还是觉得学习编程，理论固然重要，但是动手能力也很重要，编码能力<br>也很重要，这就是我学习mybatis的初次体验。</p>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>god_jiang的第一篇博客</title>
    <url>/2019/01/17/god-jiang-title/</url>
    <content><![CDATA[<p>这是我得第一个博客网站，也不知道说些啥，就是假期大家好好学习，不要过度玩电脑游戏，偶尔放松一下没啥，但是关键得ssm框架还是得先学好，下学期好找实习。。。。</p>
]]></content>
  </entry>
</search>
